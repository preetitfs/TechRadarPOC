name	ring	quadrant	isNew	description
API expand-contract	Adopt	Techniques	TRUE	<p>The <strong>API expand-contract</strong> pattern, sometimes called <a href="https://www.martinfowler.com/bliki/ParallelChange.html">parallel change</a>, will be familiar to many, especially when used with databases or code; however, we only see low levels of adoption with APIs. Specifically, we're seeing complex versioning schemes and breaking changes used in scenarios where a simple expand and then contract would suffice. For example, first adding to an API while deprecating an existing element, and then only later removing the deprecated elements once consumers are switched to the newer schema. This approach does require some coordination and visibility of the API consumers, perhaps through a technique such as <a href="https://martinfowler.com/articles/consumerDrivenContracts.html">consumer-driven contract</a> testing.</p>
Continuous delivery for machine learning (CD4ML)	Adopt	Techniques	FALSE	<p>We see <strong><a href="https://martinfowler.com/articles/cd4ml.html">continuous delivery for machine learning (CD4ML)</a></strong> as a good default starting point for any ML solution that is being deployed into production. Many organizations are becoming more reliant on ML solutions for both customer offerings and internal operations so it makes sound business sense to apply the lessons and good practice captured by <a href="/radar/techniques/continuous-delivery-cd">continuous delivery (CD)</a> to ML solutions.</p>
Design systems	Adopt	Techniques	FALSE	<p>As application development becomes increasingly dynamic and complex, it's a challenge to deliver accessible and usable products with consistent style. This is particularly true in larger organizations with multiple teams working on different products. <strong>Design systems</strong> define a collection of design patterns, component libraries and good design and engineering practices that ensure consistent digital products. Built on the corporate style guides of the past, design systems offer shared libraries and documents that are easy to find and use. Generally, guidance is written down as code and kept under version control so that the guide is less ambiguous and easier to maintain than simple documents. Design systems have become a standard approach when working across teams and disciplines in product development because they allow teams to focus. They can address strategic challenges around the product itself without reinventing the wheel every time a new visual component is needed.</p>
Platform engineering product teams	Adopt	Techniques	FALSE	<p>As noted in one of the themes for this edition, the industry is increasingly gaining experience with <strong>platform engineering product teams</strong> that create and support internal platforms. These platforms are used by teams across an organization and accelerate application development, reduce operational complexity and improve time to market. With increasing adoption we're also clearer on both good and bad patterns for this approach. When creating a platform, itâ€™s critical to have clearly defined customers and products that will benefit from it rather than building in a vacuum. We caution against <a href="/radar/techniques/layered-platform-teams">layered platform teams</a> that simply preserve existing technology silos but apply the "platform team" label as well as against ticket-driven platform operating models. We're still big fans of using concepts from <a href="https://teamtopologies.com/">Team Topologies</a> as we think about how best to organize platform teams. We consider platform engineering product teams to be a standard approach and a significant enabler for high-performing IT.</p>
Service account rotation approach	Adopt	Techniques	TRUE	<p>We strongly advise organizations to make sure, when they really need to use cloud service accounts, that they are rotating the credentials. Rotation is one of <a href="/radar/techniques/the-three-rs-of-security">the three R's of security</a>. It is far too easy for organizations to forget about these accounts unless an incident occurs. This is leading to accounts with unnecessarily broad permissions remaining in use for long periods alongside a lack of planning for how to replace or rotate them. Regularly applying a cloud <strong>service account rotation approach</strong> also provides a chance to exercise the principle of least privilege.</p>
Cloud sandboxes	Trial	Techniques	TRUE	<p>As the cloud is becoming more and more a commodity and being able to spin up <strong>cloud sandboxes</strong> is easier and available at scale, our teams prefer cloud-only (as opposed to local) development environments to reduce maintenance complexity. We're seeing that the tooling to do local simulation of cloud-native services limits the confidence in developer build and test cycles; therefore, we're looking to focus on standardizing cloud sandboxes over running cloud-native components on a developer machine. This will drive good <a href="/radar/techniques/infrastructure-as-code">infrastructure-as-code</a> practices as a forcing function and good onboarding processes for provisioning sandbox environments for developers. There are risks associated with this transition, as it assumes that developers will have an absolute dependency on cloud environment availability, and it may slow down the developer feedback loop. We strongly recommend you adopt some lean governance practices regarding standardization of these sandbox environments, especially with regard to security, IAM and regional deployments.</p>
Contextual bandits	Trial	Techniques	TRUE	<p><a href="https://towardsdatascience.com/contextual-bandits-and-reinforcement-learning-6bdfeaece72a"><strong>Contextual bandits</strong></a> is a type of reinforcement learning that is well suited for problems with exploration/exploitation trade-offs. Named after "bandits," or slot machines, in casinos, the algorithm explores different options to learn more about expected outcomes and balances it by exploiting the options that perform well. We've successfully used this technique in scenarios where we've had little data to train and deploy other machine-learning models. The fact that we can add context to this explore/exploit trade-off makes it suitable for a wide variety of use cases including A/B testing, recommendations and layout optimizations.</p>
Distroless Docker images	Trial	Techniques	FALSE	<p>When building <a href="/radar/platforms/docker">Docker</a> images for our applications, we're often concerned with two things: the security and the size of the image. Traditionally, we've used <a href="/radar/techniques/container-security-scanning">container security scanning</a> tools to detect and patch <a href="https://cve.mitre.org/">common vulnerabilities and exposures</a> and small distributions such as <a href="https://alpinelinux.org/">Alpine Linux</a> to address the image size and distribution performance. But with rising security threats, eliminating all possible attack vectors is more important than ever. That's why <strong>distroless Docker images</strong> are becoming the default choice for deployment containers. Distroless Docker images reduce the footprint and dependencies by doing away with a full operating system distribution. This technique reduces security scan noise and the application attack surface. Moreover, fewer vulnerabilities need to be patched and as a bonus, these smaller images are more efficient. Google has published a set of <a href="https://github.com/GoogleContainerTools/distroless">distroless container images</a> for different languages. You can create distroless application images using the Google build tool <a href="https://bazel.build/">Bazel</a> or simply use multistage Dockerfiles. Note that distroless containers by default don't have a shell for debugging. However, you can easily find debug versions of distroless containers online, including a <a href="https://busybox.net/downloads/BusyBox.html">BusyBox shell</a>. Distroless Docker images is a technique pioneered by Google and, in our experience, is still largely confined to Google-generated images. We would be more comfortable if there were more than one provider to choose from. Also, use caution when applying  <a href="/radar/tools/trivy">Trivy</a> or similar vulnerability scanners since distroless containers are only supported in more recent versions.</p>
Ethical Explorer	Trial	Techniques	TRUE	<p>The group behind <a href="/radar/techniques/ethical-os">Ethical OS</a> â€” the Omidyar Network, a self-described social change venture created by eBay founder Pierre Omidyar â€” has released a new iteration called <strong><a href="https://ethicalexplorer.org/">Ethical Explorer</a></strong>. The new Ethical Explorer pack draws on lessons learned from using Ethical OS and adds further questions for product teams to consider. The kit, which can be <a href="https://ethicalexplorer.org/download/">downloaded for free</a> and folded into cards to trigger discussion, has open-ended question prompts for several technical "risk zones," including surveillance ("can someone use our product or service to track or identify other users?"), disinformation, exclusion, algorithmic bias, addiction, data control, bad actors and outsized power. The included field guide has activities and workshops, ideas for starting conversations and tips for gaining organizational buy-in. While we've a long way to go as an industry to better represent the ethical externalities of our digital society, we've had some productive conversations using Ethical Explorer, and we're encouraged by the broadening awareness of the importance of product decisions in addressing societal issues.</p>
Hypothesis-driven legacy renovation	Trial	Techniques	TRUE	<p>We're often asked to refresh, update or remediate legacy systems that we didn't originally build. Sometimes, technical issues need our attention such as improving performance or reliability. One common approach to address these issues is to create "technical stories" using the same format as a user story but with a technical outcome rather than a business one. But these technical tasks are often difficult to estimate, take longer than anticipated or don't end up having the desired outcome. An alternative, more successful method is to apply <strong>hypothesis-driven legacy renovation</strong>. Rather than working toward a standard backlog, the team takes ownership of a measurable technical outcome and collectively establishes a set of hypotheses about the problem. They then conduct iterative, time-boxed experiments to verify or disprove each hypothesis in order of priority. The resulting workflow is optimized for reducing uncertainty rather than following a plan toward a predictable outcome.</p>
Lightweight approach to RFCs	Trial	Techniques	TRUE	"<p>As organizations drive toward <a href=""/radar/techniques/evolutionary-architecture"">evolutionary architecture</a>, it's important to capture decisions around design, architecture, techniques and teams' ways of workings. The process of collecting and aggregating feedback that will lead to these decisions begin with Request for Comments (RfCs). RfCs are a technique for collecting context, design and architectural ideas and collaborating with teams to ultimately come to decisions along with their context and consequences. We recommend that organizations take a <strong>lightweight approach to RFCs</strong> by using a simple standardized template across many teams as well as version control to capture RfCs.</p>

<p>It's important to capture these in an audit of these decisions to benefit future team members and to capture the technical and business evolution of an organization. Mature organizations have used RfCs in autonomous teams to drive better communication and collaboration especially in cross-team relevant decisions.</p>"
Simplest possible ML	Trial	Techniques	TRUE	<p>All major cloud providers offer a dazzling array of machine-learning (ML) solutions. These powerful tools can provide a lot of value, but come at a cost. There is the pure run cost for these services charged by the cloud provider. In addition, there is a kind of operations tax. These complex tools need to be understood and operated, and with each new tool added to the architecture this tax burden increases. In our experience, teams often choose complex tools because they underestimate the power of simpler tools such as linear regression. Many ML problems don't require a GPU or neural networks. For that reason we advocate for the <strong>simplest possible ML</strong>, using simple tools and models and a few hundred lines of Python on the compute platform you have at hand. Only reach for the complex tools when you can demonstrate the need for them.</p>
SPA injection	Trial	Techniques	TRUE	<p>The <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">strangler fig pattern</a> is often the default strategy for legacy modernization, where the new code wraps around the old and slowly absorbs the ability to handle all the needed functionality. That sort of "outside-in" approach works well for a number of legacy systems, but now that we've had enough experience with single-page applications (SPA) for them to become legacy systems themselves, we're seeing the opposite "inside-out" approach used to replace them. Instead of wrapping the legacy system, we instead embed the beginning of the new SPA into the HTML document containing the old one and let it slowly expand in functionality. The SPA frameworks don't even need to be the same as long as users can tolerate the performance hit of the increased page size (e.g., embedding a new <a href="/radar/languages-and-frameworks/react-js">React</a> app inside an old <a href="/radar/languages-and-frameworks/angularjs">AngularJS</a> one). <strong>SPA injection</strong> allows you to iteratively remove the old SPA until the new one completely takes over. Whereas a strangler fig can be viewed as a type of parasite that uses the host tree's stable external surface to support itself until it takes root and the host itself dies, this approach is more like injecting an outside agent into the host, relying on functionality of the original SPA until it can completely take over.</p>
Team cognitive load	Trial	Techniques	TRUE	<p>A system's architecture mimics organizational structure and its communication. It's not big news that we should be intentional about how teams interact â€” see, for instance, the <a href="/radar/techniques/inverse-conway-maneuver">Inverse Conway Maneuver</a>. Team interaction is one of the variables for how fast and how easily teams can deliver value to their customers. We were happy to find a way to measure these interactions; we used the <a href="https://teamtopologies.com/book">Team Topologies</a> author's <a href="https://github.com/TeamTopologies/Team-Cognitive-Load-Assessment">assessment</a> which gives you an understanding of how easy or difficult the teams find it to build, test and maintain their services. By measuring <strong>team cognitive load</strong>, we could better advise our clients on how to change their teams' structure and evolve their interactions.</p>
Tool-managed Xcodeproj	Trial	Techniques	TRUE	<p>Many of our developers coding iOS in Xcode often get headaches because the Xcodeproj file changes with every project change. The Xcodeproj file format is not human-readable, hence trying to handle merge conflicts is quite complicated and can lead to productivity loss and risk of messing up the entire project â€” if anything goes wrong with the file, Xcode won't work properly and developers will very likely be blocked. Instead of trying to merge and fix the file manually or version it, we recommend you use a <strong>tool-managed Xcodeproj</strong> approach: Define your Xcode project configuration in YAML (<a href="https://github.com/yonaskolb/XcodeGen">XcodeGen</a>, <a href="https://github.com/lyptt/struct">Struct</a>), Ruby (<a href="https://github.com/igor-makarov/xcake">Xcake</a>) or Swift (<a href="https://github.com/tuist/tuist">Tuist</a>). These tools generate the Xcodeproj file based on a configuration file and the project structure. As a result, merge conflicts in the Xcodeproj file will be a thing of the past, and when they do happen in the configuration file, they're much easier to handle.</p>
UI/BFF shared types	Trial	Techniques	TRUE	<p>With <a href="/radar/languages-and-frameworks/typescript">TypeScript</a> becoming a common language for front-end development and <a href="/radar/platforms/node-js">Node.js</a> becoming the preferred <a href="/radar/techniques/bff-backend-for-frontends">BFF</a> technology, we're seeing increasing use of <strong>UI/BFF shared types</strong>. In this technique, a single set of type definitions is used to define both the data objects returned by front-end queries and the data served to satisfy those queries by the back-end server. Ordinarily, we would be cautious about this practice because of the unnecessarily tight coupling it creates across process boundaries. However, many teams are finding that the benefits of this approach outweigh any risks of tight coupling. Since the BFF pattern works best when the same team owns both the UI code and the BFF, often storing both components in the same repository, the UI/BFF pair can be viewed as a single cohesive system. When the BFF offers strongly typed queries, the results can be tailored to the specific needs of the frontend rather than reusing a single, general-purpose entity that must serve the needs of many consumers and contain more fields than actually required. This reduces the risk of accidentally exposing data that the user shouldn't see, prevents incorrect interpretation of the returned data object and makes the query more expressive. This practice is particularly useful when implemented with <a href="/radar/languages-and-frameworks/io-ts">io-ts</a> to enforce the run-time type safety.</p>
Bounded low-code platforms	Assess	Techniques	FALSE	<p>One of the most nuanced decisions facing companies at the moment is the adoption of low-code or no-code platforms, that is, platforms that solve very specific problems in very limited domains. Many vendors are pushing aggressively into this space. The problems we see with these platforms typically relate to an inability to apply good engineering practices such as versioning. Testing too is typically really hard. However, we noticed some interesting new entrants to the market â€” including <a href="https://www.honeycode.aws/">Amazon Honeycode</a>, which makes it easy to create simple task or event management apps, and <a href="https://parabola.io/">Parabola</a> for IFTTT-like cloud workflows â€” which is why we're once again including <strong>bounded low-code platforms</strong> in this volume. Nevertheless, we remain deeply skeptical about their wider applicability since these tools, like Japanese Knotweed, have a knack of escaping their bounds and tangling everything together. That's why we still strongly advise caution in their adoption.</p>
Decentralized identity	Assess	Techniques	FALSE	<p>In 2016, Christopher Allen, a key contributor to <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">SSL/TLS</a>, inspired us with an introduction of 10 principles underpinning a new form of digital identity and a path to get there, <a href="http://www.lifewithalacrity.com/2016/04/the-path-to-self-soverereign-identity.html">the path to self-sovereign identity</a>. Self-sovereign identity, also known as <strong>decentralized identity</strong>, is a â€œlifetime portable identity for any person, organization, or thing that does not depend on any centralized authority and can never be taken away,â€ according to the <a href="/radar/platforms/trust-over-ip-stack">Trust over IP</a> standard. Adopting and implementing decentralized identity is gaining momentum and becoming attainable. We see its adoption in privacy-respecting <a href="https://www.civic.com/healthkey/">customer health applications</a>, <a href="https://www.truu.id/">government healthcare infrastructure</a> and <a href="https://id-bulletin.com/2020/06/04/news-gleif-and-evernym-demo-organization-wallets-to-deliver-trust-and-transparency-in-digital-business/">corporate legal identity</a>. If you want to rapidly get started with decentralized identity, you can assess <a href="https://sovrin.org/">Sovrin Network</a>, <a href="https://github.com/hyperledger/aries">Hyperledger Aries</a> and <a href="https://github.com/hyperledger/indy-node">Indy</a> OSS, as well as <a href="https://www.w3.org/TR/did-core/">decentralized identifiers</a> and <a href="/radar/techniques/verifiable-credentials">verifiable credentials</a> standards. We're watching this space closely as we help our clients with their strategic positioning in the new era of digital trust.</p>
Deployment drift radiator	Assess	Techniques	TRUE	<p>A <strong>deployment drift radiator</strong> makes version drift visible for deployed software across multiple environments. Organizations using automated deployments may require manual approvals for environments that get closer to production, meaning the code in these environments might well be lagging several versions behind current development. This technique makes this lag visible via a simple dashboard showing how far behind each deployed component is for each environment. This helps to highlight the opportunity cost of completed software not yet in production while drawing attention to related risks such as security fixes not yet deployed.</p>
Homomorphic encryption	Assess	Techniques	TRUE	<p>Fully <strong><a href="https://en.wikipedia.org/wiki/Homomorphic_encryption">homomorphic encryption</a></strong> (HE) refers to a class of encryption methods that allow computations (such as search and arithmetic) to be performed directly on encrypted data. The result of such a computation remains in encrypted form, which at a later point can be decrypted and revealed. Although the HE problem was first proposed in 1978, a solution wasn't constructed until 2009. With advances in computing power and the availability of easy-to-use open-source libraries â€” including <a href="https://github.com/microsoft/SEAL#introduction">SEAL</a>, <a href="https://github.com/ldsec/lattigo">Lattigo</a>, <a href="https://github.com/homenc/HElib">HElib</a> and <a href="https://github.com/data61/python-paillier">partially homomorphic encryption in Python</a> â€” HE is becoming feasible in real-world applications. The motivating scenarios include privacy-preserving use cases, where computation can be outsourced to an untrusted party, for example, running computation on encrypted data in the cloud, or enabling a third party to aggregate homomorphically encrypted intermediate <a href="https://en.wikipedia.org/wiki/Federated_learning">federated machine learning</a> results. Moreover, most HE schemes are considered to be <a href="https://csrc.nist.gov/Projects/Post-Quantum-Cryptography">secure against quantum computers</a>, and efforts are underway to <a href="https://homomorphicencryption.org/standard/">standardize</a> HE. Despite its current limitations, namely performance and feasibility of the types of computations, HE is worth your attention.</p>
Hotwire	Assess	Techniques	TRUE	"<p><strong><a href=""https://hotwire.dev/"">Hotwire</a></strong> (HTML over the wire) is a technique to build web applications. Pages are constructed out of components, but unlike modern SPAs the HTML for the components is generated on the server side and then sent ""over the wire"" to the browser. The application has only a small amount of JavaScript code in the browser to stitch the HTML fragments together. Our teams, and doubtlessly others too, experimented with this technique after asynchronous web requests gained cross-browser support around 2005, but for various reasons it never gained much traction.</p>

<p>Today, Hotwire uses modern web browser and HTTP capabilities to achieve the speed, responsiveness and dynamic nature of single-page apps (SPAs). It embraces simpler web application design by localizing the logic to the server and keeping the client-side code simple. The team at Basecamp has released a few Hotwire frameworks that power their own <a href=""https://hey.com/"">application</a>, including <a href=""https://turbo.hotwire.dev/"">Turbo</a> and <a href=""https://stimulus.hotwire.dev/"">Stimulus</a>. Turbo includes a set of techniques and frameworks to speed up the application responsiveness by preventing whole page reloading, page preview from cache and decomposing the page into fragments with progressive enhancements on request. Stimulus is designed to enhance static HTML in the browser by connecting JavaScript objects to the page elements on the HTML.</p>"
